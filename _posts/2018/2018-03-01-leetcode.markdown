---
layout: post
title: Things About Leetcode Before That Coding Interview
date: '2024-05-01 13:19'
subtitle: Leetcode IDE Tips, Common Leetcode Problems, C++ Commands
comments: true
tags:
    - Linux
    - Docker
---

## Leetcode IDE Tips

## No Global Variables

To evaluate our code samples, Leetcode simply import the file containing our implementation. Then, it will run test cases on it. If we have a global variable, the global variable will be used consistently. E.g., 

```cpp
int MyGlobalVar2;    // bad

class Solution{
    int MyGlobalVar;    // good
};
```

## Shortcuts & Debugging Tips

- `ctrl - '` is to run.
- Leetcode does support `std::cout` in a separate window `stdout`.
- no need for `std::`

## Questions

### Two Pointers

[Question Description](https://leetcode.com/problems/container-with-most-water/?envType=problem-list-v2&envId=two-pointers)

<div style="text-align: center;">
    <p align="center">
       <figure>
            <img src="https://github.com/user-attachments/assets/dedd4d95-5bc9-423f-a674-50d451950c41" height="400" alt=""/>
       </figure>
    </p>
</div>

Two pointers is a local gradient descent technique: we use 2 points starting from the head and tail of the vector. Calculate the area, then move the pointer if its side is shorter than the other. 

```cpp
    int maxArea(vector<int>& height) {
        int i_s = 0, i_e = height.size()-1;
        int max = 0;
        while (i_s != i_e){
            int area = std::min(height.at(i_s), height.at(i_e)) * (i_e - i_s); 
            max = std::max(area, max);
            if (height.at(i_s) > height.at(i_e)){
                i_e --;
            }
            else{
                i_s ++;
            }
        }
        // Why does this work? gradient descent? 
        return 0;
    }
```

In this case, it can **actually guarantee** to find the global maximum. Why? Because as we move the pointers along, we are actually evaluating:
1. what's the max when size = L
1. what's the max when size = L-1 (apparently if we move the pointer the way we do)
1. What's the max when size = L-2 (still, we can find the max there)

So we find all these local maximums, which covers all combination of sides. So, two pointers is an interesting algorithm!

## Common Leetcode Commands (C++)

### std::string

#### Substring

- `std::string substr(size_t pos = 0, size_t len = std::string::npos) const;`
    - `std::string::npos`  is optional. If not provided, it will be the full string size.
```cpp

std::string str = "Hello, World!";
std::string sub1 = str.substr(0, 5);
std::string sub3 = str.substr(7);
```

### Find Next Element

- Universal search method: `std::search(start_it, end_it, sub_element_end, sub_element_end)`

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};
std::vector<int> sub = {4, 5, 6};
auto it = std::search(vec.begin(), vec.end(), sub.begin(), sub.end());

std::list<int> lst = {10, 20, 30, 40, 50, 60};
std::list<int> sub = {30, 40};
auto it = std::search(lst.begin(), lst.end(), sub.begin(), sub.end());
```

- Vector, list:

```
auto it = std::find(vec.begin(), vec.end(), 3);
auto it = std::find(lst.begin(), lst.end(), 30);
```

- String `str.find(sub_str)`. Returns `std::string::npos` if nothing is found

```cpp
std::string str = "Hello, World!";
std::string sub = "World";
size_t pos = str.find(sub);
```
    - For string, if the search is for **tokenization**, `std::stringstream` could be more efficient for tokenization:

    ```cpp
    #include <sstream>
    stringstream ss(str);
    while (std::getline(ss, token, '/')) {
        // No '/', we get token directly
    }
    ```

#### `std::find_if(a, b, pred)`

#### `std::binary_search(vec.begin(), vec.end(), val)`  (For sorted data)

### Equate

#### `std::equal(sub.begin(), sub.end(), it)`
std::search() for subsequence matching.

### std::stack

`std::stack` is simply an adapter for `std::deque` and `std::vector`

```cpp
stack<int> sta;
sta.top();
sta.pop();
sta.empty();
sta.push();
```

- stack can be iterated over as well. So iterating over a stack will guarantee insertion order using `std::stack().size()`