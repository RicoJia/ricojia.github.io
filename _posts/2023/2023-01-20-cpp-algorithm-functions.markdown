---
layout: post
title: C++ - <algorithm>, <numeric> Functions
date: '2023-01-20 13:19'
subtitle: minmax_element, min_element, reduce, transform, numeric
comments: true
header-img: "img/post-bg-alitrip.jpg"
tags:
    - C++
---

## Introduction

In this article, we will explore two important STL libraries, `<algorithm>`, `<numeric>`. 

In `<algorithm>`, we have:

- Partitioning algorithms:
    - Placing the nth element at the nth position using `nth_element(first, nth, last, comp)`
    - Moving all elements that satisfies `pred=true` to the left of it, and leaving the rest to its left, using `it = std::partition(first, last, pred)`
- Finding the minimum and maximum using `it = std::minmax_element(begin_itr, end_itr, lambda)`, `it = std::min_element`, or `std::min(value1, value2)`
- Transforms
    - Perform an unary operation on an input sequence, then save the result in an output sequence`std::transform(input_beg, input_end, output_beg, unary_op)`.
    - Perform an accumulative operation on a sequence, and get a single value out
        - C++ 11, if the operation is sequential: `std::accumulate(beg, end, begin_val, lambda_retuning_val)`. 
        - C++ 17, we can parallelize if the operation is not associative (i.e., order of evaluation doesn't matter, a+b=b+a)`std::reduce(beg, end, begin_val, lambda_retuning_val)`

In `<numeric>`, we have:

- Datatype `std::NaN`

### Strict-Weak-Ordering 

In C++, the general ordering is done using a predicate. Most commonly, it's called "strict-weak-ordering". The same rule is followed in different places of the STL, e.g., `std::sort`, `std::map`, `std::set`, `std::priority_queue` / `std::heap` A strict weak-ordering is a binary predicate that **returns true if the first precedes the second**


```cpp
// For `std::sort`
if (Comp(pivot,new_element)) swap(pivot, element) // put larger elements to the right

// For std::priority_queue
if (Comp(parent, child)) swap(parent, child)

// For std::map
if (Comp(new_key, node_key)){
    go_left(new_key)
} else {
    go_right(new_key)
}
```


## `<algorithm>`

### Nth Element

`nth_element(first, nth, last, comp)` makes sure:

1. At `nth` place of the container, the element is actually the `nth` as if the container were sorted.
2. Elements before the nth element has `comp(i, n) = False`, or without `comp`, they are smaller than the `nth` element

```cpp
// elements before the returned iterator has a value less than or equal to the value
std::nth_element(keypoints.begin(),keypoints.begin() + desired_features_num - 1, keypoints.end(),
    [](const KeyPoint& k1, const KeyPoint& k2){
        //descending 
        return k1.response > k2.response;
    }
);
```

### Partition

`std::partition(first, last, pred)` moves all elements that makes pred(item) **true** to  first iterator, and returns an iterator that points to the first item that makes pred(item) **false**. In combination wtih `std::nth_element`, we can partition and find the iterator that makes sure all elements smaller than or equal to the `nth` elements are before a returned iterator, `new_end`.

```cpp
// we might still have elements equal to the nth element. So, we use partition to find them
// std::partion moves items that satisfies the pred to before the iterator
auto new_end = std::partition(keypoints.begin() + desired_features_num, keypoints.end(), [&keypoints](const KeyPoint& k){k.response == (keypoints.begin() + desired_features_num - 1)->response});
```

#### `std::generate_n( OutputIt out, Size count, Generator g )`
 
Assigns values, generated by given function object g, to the first count elements in the range beginning at first

```cpp
std::generate_n(
  std::back_inserter(shuffled_order),   // output iterator that does shuffled_order.push_back(x)
  4,                                     // number of elements to generate
  [&local_deck]() {                      // generator lambda, capturing your deck by reference
    return local_deck.draw_from_top();   // draws one element (e.g. a Card) from the deck
  }
);
```

- `std::back_inserter(shuffled_order)`  Creates an output iterator which, on assignment, calls `shuffled_order.push_back( value );`
    ```cpp
    template<typename Container>
    class back_insert_iterator {
        Container* container_;
        public:
        explicit back_insert_iterator(Container& c) noexcept
            : container_(&c) {}

        // core: assignment appends to the container
        back_insert_iterator& operator=(typename Container::const_reference value) {
            container_->push_back(value);
            return *this;
        }
    };
    ```
- `std::generate_n` calls `g()` count times, and assigns its return into `*out++`

## `std::minmax_element(begin_itr, end_itr, lambda)`

This function finds the `[min, max]` of a container based on the definition of "smaller".

```cpp
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};

    auto minmax = std::minmax_element(vec.begin(), vec.end(), [](const int& i1, const int& i2){
        return i1 < i2;
        // return i1>i2; // the first element (min) is the one that satisfies this condition throughout the container
    });

    // See Min element: 1
    std::cout << "Min element: " << *minmax.first << std::endl;
    std::cout << "Max element: " << *minmax.second << std::endl;

    return 0;
}
```

### `std::min_element(begin_itr, end_itr, lambda)`: returns the min element based on the defintion of "smaller"

### `std::min(v1, v2)`

## `std::transform(input_beg, input_end, output_beg, unary_op)`

`std::transform` is a funtion that allows us to apply a function (usually lambda) on one or two (zipped) containers, and puts the output into an output container.

1. unary operations

```cpp
// Definition
transform(Iterator inputBegin, Iterator inputEnd, 
        Iterator OutputBegin, unary_operation) 
// example: increment a number in an array
int arr[] = {1,2,3,4}; 
n = sizeof(arr)/sizeof(int); 
std::transform(arr, arr+n, arr, [](int x){return x+1;})
```

2. binary operation

```cpp
// Definition
transform(Iterator inputBegin1, Iterator inputEnd1, Iterator inputBegin2, 
        Iterator outputBegin, binary_operation)
// Example: arr_1 - arr 2 
int arr_1[] = {1,2,3,4}; 
int arr_2[] = {1,2,3,4}; 
int result[5]; 
std::transform(arr_1, arr_1+4, arr_2, result, [](int i1, i2){return i1 - i2; }); 
```

- `std::transform(It1 it1_begin, It1, it1_end, It2 it2_end, It3 out_begin, [](const Type1& a, const Type2&b){return something})`

3. Sort + Binary search: 

```cpp
std::sort();
std::binary_search() -> bool
```


### `std::accumulate(beg, end, begin_val, lambda_retuning_val)`

1. simple summing

```cpp
#include <numeric>
sum = std::accumulate(vec.begin(), vec.end(), 0.0); 
```

- Note: in the below example, sum will be casted to int, even if `std::vector<double> vec`:

```cpp
sum = std::accumulate(vec.begin(), vec.end(), 0); 
```

2. Other accumulative tasks:

```cpp
T accumulate(Iterator first, Iterator Last, T init, Binary_Operation op){
    for(; first != last; ++first){
    init = op(std::move(init), *first); 
    }
}
```

- E.g,

```cpp
std::accumulate(vec.begin(), vec.end(), 1, [](int product, int b){return product*b}); 
```

### `std::reduce(beg, end, begin_val, lambda_retuning_val)` (C++17)

`std::reduce` is an algorithm introduced in C++17 (and enhanced in C++20) that aggregates a range of elements using a binary operation and an initial value. 

**Unlike `std::accumulate`, `std::reduce` has no guaranteed order of evaluation, which allows it to be parallelized for improved performance.** However, because it processes elements in an unspecified order, the binary operation should be **both associative and commutative** to guarantee correct results.

```cpp
#include <optional>
#include <iostream>
#include <vector>
#include <numeric>
using namespace std;

void test_reduce(){
    std::vector<int> vec {1,2,3,4,5};
    // order of execution is unspecified
    double sum = std::reduce(
        std::execution::par_unseq,
        vec.begin(), vec.end(), 0.0, [](int a, double sum){return 0.25*a + sum;});
    cout<<"using reduce to find sum: "<<sum<<endl;
}

int main(){
    // test_optional();
    test_reduce();

}
```

- `std::execution::par_unseq` parallelizes the above.
-  Pay attention to the initial value `0.0`, otherwise, it will be an int and will be rounded.

## `std::numeric`

### NaN: (C++11)

- `std::numeric_limits<float>::quiet_NaN()`: propagates through arithmetic operations without triggering floating-point exceptions.

```cpp
    float nan_value = std::numeric_limits<float>::quiet_NaN();

    std::cout << "NaN value: " << nan_value << std::endl;

    // Checking if a value is NaN
    if (std::isnan(nan_value)) {
        std::cout << "The value is NaN." << std::endl;
    }
    // Propagation example
    float result = nan_value + 5.0f;  // Still NaN
    std::cout << "Result of NaN + 5: " << result << std::endl;

```

- `std::numeric_limits<T>::signaling_NaN`: signaling NaN (SNaN) raises an exception when used in computations.